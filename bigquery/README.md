# BigQueryの構成要素
1. Dremel→コンピューティング
2. Colossus→分散ストレージ
3. Jupiter network→ネットワーク
4. Borg→オーケストレーション

# 動的クエリ実行について
ユーザー側がシステムを考慮してデータの扱いやクエリを気にかける必要はなくDremelでそういった部分はメタデータを用いながらクエリの各段階を自動的に構成されます。そのためユーザーはクエリの実行速度や消費するスロットに注意してクエリを作ることになります。

# データセットのアクセス制御
GCPで使われるアクセス制御のIAMでデータセットのアクセスを制御します。

管理のベストプラクティスとしては、BQリソースは組織単位からの管理を開始してそれ以降を用途に応じて制限する方法を取ります。

# スロット
BQのクエリはDremel内のvCPU一つにつき1スロットと計算してそれらをクエリにてどれだけ使うかがリソース使用の1つの要因となります。

料金モデルに応じてスロットの消費方法は変わります。

BQのクエリは動的DAGが用いられ最適並列化数を計算してそれに合わせて分散実行がされます。

消費スロットは料金サービスによりますがその時扱えるスロット数と最適並列化数の兼ね合いで順次実行されます。

# クエリの費用を下げる
- SELECT *を避ける

    LIMIT句を使ってもスキャン量は変わらないため必要なデータのみ読み取るようにする
- テーブルを日付別のパーティショニングにする

    日付別にすることでクエリ対象とするテーブルが絞れるため更にスキャン量を減らせる

- データの確認にはプレビューで行う

    bqコマンドを使ってbq headでプレビューする行数を設定できる

- bq --dry_runでクエリを見積もる

    --dry_runでクエリで処理されるバイト数の見積もりが計算されるためそれを料金計算ツール用いてコスト計算することができる
- 課金されるバイト数の制限を設定する
- クラスタ化の検討とLIMIT句の使用

    パーティショニングと同様にクラスタにすることでテーブルのスキャン量を減らせる。また、クラスタテーブルであればLIMIT句でもスキャン量が減る。
- ダッシュボードによる監視
- クエリ結果を段階的にテーブルとして保存して分割して実行されるようにする
- テーブルの有効期限を設定して古いものを自動削除するように設定する
- データストリーミングは料金が発生するため必要性を検討する
# Ref
- [Separation of storage and compute in BigQuery](https://cloud.google.com/blog/products/bigquery/separation-of-storage-and-compute-in-bigquery)
- [スロット](https://cloud.google.com/bigquery/docs/slots)
- [BigQuery リソースの整理](https://cloud.google.com/bigquery/docs/resource-hierarchy)
- [BigQuery で費用を抑える](https://cloud.google.com/bigquery/docs/best-practices-costs)